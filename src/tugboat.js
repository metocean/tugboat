// Generated by CoffeeScript 1.9.1
var Ducke, Tugboat, copy, fs, groupdiff, parallel, parse_configuration, path, require_raw, seq, series, servicediff, yaml,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Ducke = require('ducke');

yaml = require('js-yaml');

fs = require('fs');

path = require('path');

parse_configuration = require('./configuration');

groupdiff = require('./groupdiff');

servicediff = require('./servicediff');

series = require('./series');

parallel = require('./parallel');

seq = require('./seq');

require_raw = require('./require_raw');

copy = function(source, target) {
  var key, results1, value;
  results1 = [];
  for (key in source) {
    value = source[key];
    if (typeof value === 'object') {
      if ((target[key] == null) || typeof target[key] !== 'object') {
        target[key] = {};
      }
      results1.push(copy(value, target[key]));
    } else {
      results1.push(target[key] = value);
    }
  }
  return results1;
};

module.exports = Tugboat = (function() {
  function Tugboat(options) {
    this.keep = bind(this.keep, this);
    this.migrate = bind(this.migrate, this);
    this.cull = bind(this.cull, this);
    this.kill = bind(this.kill, this);
    this.start = bind(this.start, this);
    this.rm = bind(this.rm, this);
    this.stop = bind(this.stop, this);
    this.create = bind(this.create, this);
    this.groupup = bind(this.groupup, this);
    this.groupcull = bind(this.groupcull, this);
    this.diff = bind(this.diff, this);
    this.ps = bind(this.ps, this);
    this.build = bind(this.build, this);
    this.init = bind(this.init, this);
    this._loadGroup = bind(this._loadGroup, this);
    this._options = {
      groupsdir: process.cwd()
    };
    copy(options, this._options);
    this.ducke = new Ducke.API(Ducke.Parameters(options));
  }

  Tugboat.prototype._loadGroup = function(item, cb) {
    return fs.readFile(item, {
      encoding: 'utf8'
    }, (function(_this) {
      return function(err, content) {
        var e, name;
        if (err != null) {
          return cb([err]);
        }
        try {
          content = yaml.safeLoad(content);
        } catch (_error) {
          e = _error;
          if (e != null) {
            return cb([e]);
          }
        }
        name = path.basename(item, '.yml');
        return parse_configuration(name, content, _this._options.groupsdir, function(errors, services) {
          if (errors != null) {
            return cb(errors);
          }
          return cb(null, {
            name: name,
            path: item,
            services: services
          });
        });
      };
    })(this));
  };

  Tugboat.prototype.init = function(callback) {
    var e, errors, fn, item, items, j, len, results, tasks;
    try {
      items = fs.readdirSync(this._options.groupsdir);
    } catch (_error) {
      e = _error;
      return callback([
        {
          path: this._options.groupsdir,
          errors: [e]
        }
      ]);
    }
    if (this._groups == null) {
      this._groups = {};
    }
    tasks = [];
    errors = [];
    results = [];
    fn = (function(_this) {
      return function(item) {
        return tasks.push(function(cb) {
          item = _this._options.groupsdir + "/" + item;
          return _this._loadGroup(item, function(errs, group) {
            if (errs != null) {
              errors.push({
                path: item,
                errors: errs
              });
              return cb();
            }
            _this._groups[group.name] = group;
            return cb();
          });
        });
      };
    })(this);
    for (j = 0, len = items.length; j < len; j++) {
      item = items[j];
      if (!item.match(/\.yml$/)) {
        continue;
      }
      fn(item);
    }
    return parallel(tasks, function() {
      if (errors.length !== 0) {
        return callback(errors);
      }
      return callback(null);
    });
  };

  Tugboat.prototype.build = function(group, service, usecache, run, callback) {
    return this.ducke.build_image(service.name, service.build, usecache, run, callback);
  };

  Tugboat.prototype.ps = function(callback) {
    return this.ducke.ps((function(_this) {
      return function(err, containers) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, groupdiff(_this._groups, containers));
      };
    })(this));
  };

  Tugboat.prototype.diff = function(callback) {
    return this.ducke.ps((function(_this) {
      return function(err, containers) {
        if (err != null) {
          return callback(err);
        }
        return _this.ducke.ls(function(err, imagerepo) {
          var images;
          if (err != null) {
            return callback(err);
          }
          images = containers.map(function(c) {
            return c.inspect.Image;
          });
          return _this.ducke.lls(images, function(err, detailedimages) {
            var e, groupsgrouped, id, inspect, servicesdiffed;
            if (err != null) {
              return callback(err);
            }
            for (id in detailedimages) {
              inspect = detailedimages[id];
              imagerepo.ids[id].inspect = inspect;
            }
            groupsgrouped = groupdiff(_this._groups, containers);
            servicesdiffed = servicediff(imagerepo, groupsgrouped);
            try {
              return callback(null, servicesdiffed);
            } catch (_error) {
              e = _error;
              console.error('   Unhandled error in tugboat.diff:'.red, e);
              return process.exit(1);
            }
          });
        });
      };
    })(this));
  };

  Tugboat.prototype.groupcull = function(groupdiff, callback) {
    var c, containername, errors, fn, j, len, messages, outputname, ref, ref1, service, servicename, tasks;
    errors = [];
    messages = [];
    tasks = [];
    ref = groupdiff.services;
    for (servicename in ref) {
      service = ref[servicename];
      outputname = servicename;
      while (outputname.length < 26) {
        outputname += ' ';
      }
      ref1 = service.containers;
      fn = (function(_this) {
        return function(containername, c, outputname, service) {
          if (c.inspect.State.Running) {
            tasks.push(function(cb) {
              messages.push(outputname + " Stopping " + containername);
              return _this.ducke.container(c.container.Id).stop(function(err, result) {
                if (err != null) {
                  errors.push(err);
                }
                return cb();
              });
            });
          }
          return tasks.push(function(cb) {
            messages.push(outputname + " Deleting " + containername);
            return _this.ducke.container(c.container.Id).rm(function(err, result) {
              if (err != null) {
                errors.push(err);
              }
              return cb();
            });
          });
        };
      })(this);
      for (j = 0, len = ref1.length; j < len; j++) {
        c = ref1[j];
        containername = c.container.Names[0].substr('1');
        fn(containername, c, outputname, service);
      }
    }
    return series(tasks, function() {
      return callback(errors, messages);
    });
  };

  Tugboat.prototype.groupup = function(groupdiff, callback) {
    var errors, fn, messages, outputname, ref, service, servicename, tasks;
    errors = [];
    messages = [];
    tasks = [];
    ref = groupdiff.services;
    fn = (function(_this) {
      return function(outputname, service) {
        var c, containername, fn1, fn2, fn3, i, j, k, l, len, len1, len2, n, ref1, ref2, ref3, ref4, results1;
        tasks.push(function(cb) {
          var j, k, len, len1, m, ref1, ref2;
          if (service.diff.iserror) {
            ref1 = service.diff.messages;
            for (j = 0, len = ref1.length; j < len; j++) {
              m = ref1[j];
              errors.push(outputname + " " + m);
            }
          } else {
            ref2 = service.diff.messages;
            for (k = 0, len1 = ref2.length; k < len1; k++) {
              m = ref2[k];
              messages.push(outputname + " " + m);
            }
          }
          return cb();
        });
        ref1 = service.diff.stop;
        fn1 = function(containername, c) {
          return tasks.push(function(cb) {
            messages.push(outputname + " Stopping " + containername);
            return _this.ducke.container(c.container.Id).stop(function(err, result) {
              if (err != null) {
                errors.push(err);
              }
              return cb();
            });
          });
        };
        for (j = 0, len = ref1.length; j < len; j++) {
          c = ref1[j];
          containername = c.container.Names[0].substr('1');
          fn1(containername, c);
        }
        ref2 = service.diff.rm;
        fn2 = function(containername, c) {
          return tasks.push(function(cb) {
            messages.push(outputname + " Deleting " + containername);
            return _this.ducke.container(c.container.Id).stop(function(err, result) {
              if (err != null) {
                errors.push(err);
              }
              return cb();
            });
          });
        };
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          c = ref2[k];
          containername = c.container.Names[0].substr('1');
          fn2(containername, c);
        }
        ref3 = service.diff.start;
        fn3 = function(containername, c) {
          return tasks.push(function(cb) {
            messages.push(outputname + " Starting " + containername);
            return _this.ducke.container(c.container.Id).stop(function(err, result) {
              if (err != null) {
                errors.push(err);
              }
              return cb();
            });
          });
        };
        for (l = 0, len2 = ref3.length; l < len2; l++) {
          c = ref3[l];
          containername = c.container.Names[0].substr('1');
          fn3(containername, c);
        }
        if (service.diff.create > 0) {
          results1 = [];
          for (i = n = 1, ref4 = service.diff.create; 1 <= ref4 ? n <= ref4 : n >= ref4; i = 1 <= ref4 ? ++n : --n) {
            results1.push(tasks.push(function(cb) {
              var newindex, newname;
              newname = groupdiff.name + "_" + service.name;
              newindex = 1;
              while (service.containers.filter(function(c) {
                  return c.index === newindex.toString();
                }).length !== 0) {
                newindex++;
              }
              newname += "_" + newindex;
              messages.push(outputname + " Creating " + newname + " (" + service.service.params.Image + ") ");
              return _this.create(groupdiff, service.service, newname, function(err) {
                if (err != null) {
                  errors.push(err);
                }
                return cb();
              });
            }));
          }
          return results1;
        }
      };
    })(this);
    for (servicename in ref) {
      service = ref[servicename];
      outputname = servicename;
      while (outputname.length < 26) {
        outputname += ' ';
      }
      fn(outputname, service);
    }
    return series(tasks, function() {
      return callback(errors, messages);
    });
  };

  Tugboat.prototype.create = function(group, service, callback) {
    var create, ref, ref1;
    create = (ref = service.service) != null ? (ref1 = ref.scripts) != null ? ref1.create : void 0 : void 0;
    if (create == null) {
      create = __dirname + "/../scripts/create.js";
    }
    return require_raw(create)(this, this.ducke, seq, group, service, callback);
  };

  Tugboat.prototype.stop = function(group, service, container, callback) {
    var ref, ref1, stop;
    stop = (ref = service.service) != null ? (ref1 = ref.scripts) != null ? ref1.stop : void 0 : void 0;
    if (stop == null) {
      stop = __dirname + "/../scripts/stop.js";
    }
    return require_raw(stop)(this, this.ducke, seq, group, service, container, callback);
  };

  Tugboat.prototype.rm = function(group, service, container, callback) {
    var ref, ref1, rm;
    rm = (ref = service.service) != null ? (ref1 = ref.scripts) != null ? ref1.rm : void 0 : void 0;
    if (rm == null) {
      rm = __dirname + "/../scripts/rm.js";
    }
    return require_raw(rm)(this, this.ducke, seq, group, service, container, callback);
  };

  Tugboat.prototype.start = function(group, service, container, callback) {
    var ref, ref1, start;
    start = (ref = service.service) != null ? (ref1 = ref.scripts) != null ? ref1.start : void 0 : void 0;
    if (start == null) {
      start = __dirname + "/../scripts/start.js";
    }
    return require_raw(start)(this, this.ducke, seq, group, service, container, callback);
  };

  Tugboat.prototype.kill = function(group, service, container, callback) {
    var kill, ref, ref1;
    kill = (ref = service.service) != null ? (ref1 = ref.scripts) != null ? ref1.kill : void 0 : void 0;
    if (kill == null) {
      kill = __dirname + "/../scripts/kill.js";
    }
    return require_raw(kill)(this, this.ducke, seq, group, service, container, callback);
  };

  Tugboat.prototype.cull = function(group, service, container, callback) {
    var cull, ref, ref1;
    cull = (ref = service.service) != null ? (ref1 = ref.scripts) != null ? ref1.cull : void 0 : void 0;
    if (cull == null) {
      cull = __dirname + "/../scripts/cull.js";
    }
    return require_raw(cull)(this, this.ducke, seq, group, service, container, callback);
  };

  Tugboat.prototype.migrate = function(group, service, container, callback) {
    var migrate, ref, ref1;
    migrate = (ref = service.service) != null ? (ref1 = ref.scripts) != null ? ref1.migrate : void 0 : void 0;
    if (migrate == null) {
      migrate = __dirname + "/../scripts/migrate.js";
    }
    return require_raw(migrate)(this, this.ducke, seq, group, service, container, callback);
  };

  Tugboat.prototype.keep = function(group, service, container, callback) {
    var keep, ref, ref1;
    keep = (ref = service.service) != null ? (ref1 = ref.scripts) != null ? ref1.keep : void 0 : void 0;
    if (keep == null) {
      keep = __dirname + "/../scripts/keep.js";
    }
    return require_raw(keep)(this, this.ducke, seq, group, service, container, callback);
  };

  return Tugboat;

})();
