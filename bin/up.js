// Generated by CoffeeScript 1.8.0
var init_errors, series;

series = require('../src/series');

init_errors = require('./errors');

module.exports = function(tugboat, groupname, servicenames) {
  return tugboat.init(function(errors) {
    if (errors != null) {
      return init_errors(errors);
    }
    return tugboat.diff(function(err, results) {
      var outputname, service, tasks, _, _fn, _ref;
      if (err != null) {
        if (err.stack) {
          console.error(err.stack);
        } else {
          console.error(err);
        }
        return;
      }
      tasks = [];
      console.log();
      console.log("  Updating " + groupname.blue + "...");
      console.log();
      _ref = results[groupname].services;
      _fn = function(outputname, service) {
        var c, i, _fn1, _fn2, _fn3, _fn4, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
        tasks.push(function(cb) {
          var m, _i, _j, _len, _len1, _ref1, _ref2;
          if (service.diff.iserror) {
            console.error("  " + outputname + " " + 'Error:'.red);
            _ref1 = service.diff.messages;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              m = _ref1[_i];
              console.log("  " + outputname + " " + m.red);
            }
            return cb();
          }
          _ref2 = service.diff.messages;
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            m = _ref2[_j];
            console.log("  " + outputname + " " + m.magenta);
          }
          return cb();
        });
        _ref1 = service.diff.stop;
        _fn1 = function(c) {
          return tasks.push(function(cb) {
            process.stdout.write("  " + outputname + " Stopping " + (c.container.Names[0].substr('1').cyan) + " ");
            return tugboat.ducke.container(c.container.Id).stop(function(err, result) {
              if (err != null) {
                console.error('X'.red);
                if (err.stack) {
                  console.error(err.stack);
                } else {
                  console.error(err);
                }
                return;
              }
              console.error('√'.green);
              return cb();
            });
          });
        };
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          _fn1(c);
        }
        _ref2 = service.diff.rm;
        _fn2 = function(c) {
          return tasks.push(function(cb) {
            process.stdout.write("  " + outputname + " Deleting " + (c.container.Names[0].substr('1').cyan) + " ");
            return tugboat.ducke.container(c.container.Id).rm(function(err, result) {
              if (err != null) {
                console.error('X'.red);
                if (err.stack) {
                  console.error(err.stack);
                } else {
                  console.error(err);
                }
                return;
              }
              console.error('√'.green);
              return cb();
            });
          });
        };
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          c = _ref2[_j];
          _fn2(c);
        }
        _ref3 = service.diff.start;
        _fn3 = function(c) {
          return tasks.push(function(cb) {
            process.stdout.write("  " + outputname + " Starting " + (c.container.Names[0].substr('1').cyan) + " ");
            return tugboat.ducke.container(c.container.Id).start(function(err, result) {
              if (err != null) {
                console.error('X'.red);
                if (err.stack) {
                  console.error(err.stack);
                } else {
                  console.error(err);
                }
                return;
              }
              console.error('√'.green);
              return cb();
            });
          });
        };
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          c = _ref3[_k];
          _fn3(c);
        }
        _ref4 = service.diff.keep;
        _fn4 = function(c) {
          return tasks.push(function(cb) {
            console.log("  " + outputname + " Keeping " + (c.container.Names[0].substr('1').cyan));
            return cb();
          });
        };
        for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
          c = _ref4[_l];
          _fn4(c);
        }
        if (service.diff.create > 0) {
          _results = [];
          for (i = _m = 1, _ref5 = service.diff.create; 1 <= _ref5 ? _m <= _ref5 : _m >= _ref5; i = 1 <= _ref5 ? ++_m : --_m) {
            _results.push(tasks.push(function(cb) {
              var newindex, newname;
              newname = "" + groupname + "_" + service.name;
              newindex = 1;
              while (service.containers.filter(function(c) {
                  return c.index === newindex.toString();
                }).length !== 0) {
                newindex++;
              }
              newname += "_" + newindex;
              process.stdout.write("  " + outputname + " Creating new container " + newname.cyan + " (" + service.service.params.Image + ") ");
              return tugboat.up(service.service, newname, function(err) {
                if (err != null) {
                  console.error('X'.red);
                  if (err.stack) {
                    console.error(err.stack);
                  } else {
                    console.error(err);
                  }
                  return;
                }
                console.error('√'.green);
                return cb();
              });
            }));
          }
          return _results;
        }
      };
      for (_ in _ref) {
        service = _ref[_];
        outputname = service.name.cyan;
        while (outputname.length < 36) {
          outputname += ' ';
        }
        _fn(outputname, service);
      }
      return series(tasks, function() {
        return console.log();
      });
    });
  });
};
